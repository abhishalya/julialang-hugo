<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>Some fun with &amp;pi; in Julia</title>
<meta name="author" content="Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al." />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="Official website for the Julia programming language. Join the Julia community today.">

<meta property="og:title" content="The Julia Language"/>
<meta property="og:image" content="http://www.julialang.org/images/julia-open-graph.png"/>
<meta property="og:description" content="Official website for the Julia programming language"/>

<link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,500,500i,700,700i" rel="stylesheet">
<link rel="stylesheet" href="/v2/css/bootstrap.min.css" />
<link rel="stylesheet" href="/v2/css/app.css" />
<link rel="stylesheet" href="/v2/css/fonts.css" />
<link rel="stylesheet" href="/v2/css/highlight/github.css" />

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"
    onload="renderMathInElement(document.body, {
        delimiters: [
          {left: '$[[', right: ']]', display: true},
          {left: '\\[', right: '\\]', display: true},
          {left: '[[', right: ']]', display: false}
        ]
      });"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-28835595-1');
</script>

  

  
</head>

<body>
  
  

<div class="container py-3 py-lg-0">
  <nav class="navbar navbar-expand-lg navbar-light bg-light" id="main-menu">

    <a class="navbar-brand" href="/" id="logo">
      <img src="/v2/img/logo.svg" height="55" width="85" alt="JuliaLang Logo"/>
    </a>

    <button class="navbar-toggler ml-auto hidden-sm-up float-xs-left" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item  flex-md-fill text-md-center">
          <a class="nav-link" href="/downloads">Download</a>
        </li>
        <li class="nav-item flex-md-fill text-md-center">
          <a class="nav-link" href="//docs.julialang.org">Documentation</a>
        </li>
        <li class="nav-item  flex-md-fill text-md-center">
          <a class="nav-link" href="/blog/">Blog</a>
        </li>
        <li class="nav-item  flex-md-fill text-md-center">
          <a class="nav-link" href="/community">Community</a>
        </li>
        <li class="nav-item  flex-md-fill text-md-center">
          <a class="nav-link" href="/learning">Learning</a>
        </li>
        <li class="nav-item  flex-md-fill text-md-center">
          <a class="nav-link" href="/research">Research</a>
        </li>
        <li class="nav-item  flex-md-fill text-md-center">
          <a class="nav-link" href="/soc/ideas-page">JSoC</a>
        </li>
        <li class="nav-item donate flex-md-fill text-md-center">
          <a class="btn btn-success" href="https://numfocus.org/donate-to-julia">Donate</a>
        </li>
      </ul>
    </div>

  </nav>
</div>



  <br /><br />

  <div class="container">

  <div id="blogpost">
    <h1>Some fun with &amp;pi; in Julia</h1>

    <p class="metadata">
      <span class="timestamp">14 March, 2017</span>
      
      &nbsp;|&nbsp;
      <span class="author">Simon Byrne, Luis Benet and David Sanders</span>
      
    </p>

    <!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><img src="/images/blog/2017-03-14-piday/pi.png" alt="pi">
<em>Image courtesy of <a href="https://github.com/cormullion">Cormullion</a>, code <a href="https://gist.github.com/cormullion/e979d819e478da73280faaeb67490888">here</a>.</em></p>
<p><em>This post is available as a Jupyter notebook <a href="https://github.com/simonbyrne/Pi.jl/blob/master/pi.ipynb">here</a></em></p>
<h2 id="pi-in-julia">π in Julia</h2>
<p><em>(<a href="https://github.com/simonbyrne">Simon Byrne</a>)</em></p>
<p>Like most technical languages, Julia provides a variable constant for π. However Julia's handling is a bit special.</p>
<pre><code class="language-julia">pi
</code></pre>
<pre><code>π = 3.1415926535897...
</code></pre>
<p>It can also be accessed via the unicode symbol (you can get it at the REPL or in a notebook via the TeX completion <code>\pi</code> followed by a tab)</p>
<pre><code class="language-julia">π
</code></pre>
<pre><code>π = 3.1415926535897...
</code></pre>
<p>You'll notice that it doesn't print like an ordinary floating point number: that's because it isn't one.</p>
<pre><code class="language-julia">typeof(pi)
</code></pre>
<pre><code>Irrational{:π}
</code></pre>
<p>π and a few other irrational constants are instead stored as special <code>Irrational</code> values, rather than being rounded to <code>Float64</code>. These act like ordinary numeric values, except that they can are converted automatically to any floating point type without any intermediate rounding:</p>
<pre><code class="language-julia">1 + pi # integers are promoted to Float64 by default
</code></pre>
<pre><code>4.141592653589793
</code></pre>
<pre><code class="language-julia">Float32(1) + pi # Float32
</code></pre>
<pre><code>4.141593f0
</code></pre>
<p>This is particularly useful for use with arbitrary-precision <code>BigFloat</code>s, as π can be evaluated to full precision (rather than be truncated to <code>Float64</code> and converted back).</p>
<pre><code class="language-julia">BigFloat(1) + pi # 256 bits by default
</code></pre>
<pre><code>4.141592653589793238462643383279502884197169399375105820974944592307816406286198
</code></pre>
<p>If π were stored as a <code>Float64</code>, we would instead get</p>
<pre><code class="language-julia">BigFloat(1) + Float64(pi)
</code></pre>
<pre><code>4.141592653589793115997963468544185161590576171875000000000000000000000000000000
</code></pre>
<p>In fact <code>BigFloat</code> (which uses the <a href="http://www.mpfr.org">MPFR</a> library) will compute π on demand to the current precision, which is set via <code>setprecision</code>. This provides an easy way to get its digits:</p>
<pre><code class="language-julia"># to 1024 bits
setprecision(BigFloat, 1024) do 
    BigFloat(pi)
end
</code></pre>
<pre><code>3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724586997
</code></pre>
<p>The last few printed digits may be incorrect due to the conversion from the internal binary format of <code>BigFloat</code> to the decimal representation used for printing.
This is just a presentation issue, however – the internal binary representation is correctly rounded to the last bit.</p>
<p>Another neat property of <code>Irrational</code>s is that inequalities are correct:</p>
<pre><code class="language-julia">Float64(pi) &lt; pi &lt; nextfloat(Float64(pi))
</code></pre>
<pre><code>true
</code></pre>
<h2 id="pi-via-inline-assembly-instructions">π via inline assembly instructions</h2>
<p><em>(<a href="https://github.com/simonbyrne">Simon Byrne</a>)</em></p>
<p>Julia provides a very low-level <code>llvmcall</code> interface, which allows the user to directly write <a href="http://llvm.org/docs/LangRef.html">LLVM intermediate representation</a>, including the use of inline assembly. The following snippet calls the <code>fldpi</code> instruction (&quot;<strong>f</strong>loating point <strong>l</strong>oa<strong>d</strong> <strong>pi</strong>&quot;) which loads the constant π onto the floating point register stack (this works only on x86 and x86_64 architectures)</p>
<pre><code class="language-julia">function asm_pi()
    Base.llvmcall(
    &quot;&quot;&quot; %pi = call double asm &quot;fldpi&quot;, &quot;={st}&quot;()
        ret double %pi&quot;&quot;&quot;, 
    Float64, Tuple{})
end
</code></pre>
<pre><code>asm_pi (generic function with 1 method)
</code></pre>
<pre><code class="language-julia">asm_pi()
</code></pre>
<pre><code>3.141592653589793
</code></pre>
<p>We can look at the actual resulting code that is generated:</p>
<pre><code class="language-julia">@code_native asm_pi()
</code></pre>
<pre><code>    .section	__TEXT,__text,regular,pure_instructions
Filename: In[10]
    pushq	%rbp
    movq	%rsp, %rbp
Source line: 2
    fldpi
    fstpl	-8(%rbp)
    movsd	-8(%rbp), %xmm0         ## xmm0 = mem[0],zero
    popq	%rbp
    retq
</code></pre>
<p>If you're wondering what the rest of these instructions are doing:</p>
<ol>
<li>the <code>pushq</code> and <code>movq</code> adds to the <a href="https://en.wikipedia.org/wiki/Call_stack">call stack frame</a>.</li>
<li><code>fldpi</code> pushes π to the x87 floating point register stack</li>
</ol>
<ul>
<li>x87 is the older legacy floating point instruction set dating back to the original <a href="https://en.wikipedia.org/wiki/Intel_8087">Intel 8087 coprocessor</a>.</li>
</ul>
<ol start="3">
<li><code>fstpl</code> and <code>movsd</code> moves the value to the SSE floating point register <code>xmm0</code></li>
</ol>
<ul>
<li>Julia, like most modern software, uses the newer SSE instruction set for its floating point operations. This also allows us to take advantage of things like <a href="https://en.wikipedia.org/wiki/SIMD">SIMD operations</a>.</li>
</ul>
<ol start="4">
<li><code>popq</code> and <code>retq</code> pops the call stack frame.</li>
</ol>
<h2 id="pi-using-a-taylor-series-expansions">π using a Taylor series expansions</h2>
<p><em>(<a href="https://github.com/lbenet">Luis Benet</a>, Instituto de Ciencias Físicas, Universidad Nacional Autónoma de México (UNAM))</em></p>
<p>This will demonstrate how to evaluate π using various Taylor series expansions via the <a href="https://github.com/JuliaDiff/TaylorSeries.jl">TaylorSeries.jl</a> package.</p>
<pre><code class="language-julia">using TaylorSeries
</code></pre>
<h3 id="madhavas-formula">Madhava's formula</h3>
<p>One of the standard trigonmetric identities is
$$ \tan\left( \frac{\pi}{6} \right) = \frac{1}{\sqrt{3}}. $$</p>
<p>Therefore, by taking the Taylor expansion of $ 6 \arctan(x) $ around 0 we may obtain the value of $\pi$, by evaluating it at $1/\sqrt{3}$, a value which is within the radius of convergence.</p>
<p>We obtain the Taylor series of order 37th, using <code>BigFloat</code>s:</p>
<pre><code class="language-julia">series1 = 6atan( Taylor1(BigFloat, 37) )
convert(Taylor1{Rational{BigInt}},series1)
</code></pre>
<pre><code> 6//1 t - 2//1 t³ + 6//5 t⁵ - 6//7 t⁷ + 2//3 t⁹ - 6//11 t¹¹ + 6//13 t¹³ - 2//5 t¹⁵ + 6//17 t¹⁷ - 6//19 t¹⁹ + 2//7 t²¹ - 6//23 t²³ + 6//25 t²⁵ - 2//9 t²⁷ + 6//29 t²⁹ - 6//31 t³¹ + 2//11 t³³ - 6//35 t³⁵ + 6//37 t³⁷ + 𝒪(t³⁸)
</code></pre>
<p>Note that the series above has only odd powers, so we will be using in this case 18 coefficients.</p>
<p>Evaluating that expression in $1/\sqrt{3}$ we get</p>
<pre><code class="language-julia">pi_approx1 = evaluate(series1, 1/sqrt(big(3)))
</code></pre>
<pre><code>3.141592653647826046431202390582141253830948237428790668441592864548346569098516
</code></pre>
<p>Then, the 37th order Taylor expansion yields a value which differs from $\pi$ in:</p>
<pre><code class="language-julia">abs(pi - pi_approx1)
</code></pre>
<pre><code>5.803280796855900730263836963377883805368484746664827224053016281231814650118929e-11
</code></pre>
<p>To obtain more accurate results, we may simply increase the order of the expansion:</p>
<pre><code class="language-julia">series2 = 6atan( Taylor1(BigFloat,99) ) # 49 coefficients of the series
pi_approx2 = evaluate(series2, 1/sqrt(BigInt(3)))
</code></pre>
<pre><code>3.141592653589793238462643347272152237127662423839333289949470742535834074912581
</code></pre>
<pre><code class="language-julia">abs(pi - pi_approx2)
</code></pre>
<pre><code>3.600735064706950697553577253102547384977198233137361734413175534929622111373249e-26
</code></pre>
<p>This formulation is one of the <a href="https://en.wikipedia.org/wiki/Madhava_series#Another_formula_for_the_circumference_of_a_circle"><em>Madhava</em> or <em>Gregory–Leibniz series</em></a>:</p>
<p>\begin{equation}
\pi = 6 \sum_{n=0}^{\infty} (-1)^n \frac{(1/\sqrt{3})^{2n+1}}{2n+1}.
\end{equation}</p>
<h3 id="machins-approach">Machin's approach</h3>
<p>Following the same idea, <a href="https://en.wikipedia.org/wiki/John_Machin#Formula">John Machin</a> derived an algorithm which converges much faster, using the identity</p>
<p>\begin{equation}
\frac{\pi}{4} = 4 \arctan\left(\frac{1}{5}\right) - \arctan\left(\frac{1}{239}\right).
\end{equation}</p>
<p>Following what we did above, using again a 37th Taylor expansion:</p>
<pre><code class="language-julia">ser = atan( Taylor1(BigFloat, 37) )
pi_approx3 = 4*( 4*evaluate(ser, 1/big(5)) - evaluate(ser, 1/big(239)) )
</code></pre>
<pre><code>3.141592653589793238462643383496777424642594661632063407072684671069773618535135
</code></pre>
<pre><code class="language-julia">abs(pi - pi_approx3)
</code></pre>
<pre><code>2.17274540445425262256957586097740078761957212248936631045983596428448951876822e-28
</code></pre>
<h2 id="finding-guaranteed-bounds-on-pi">Finding guaranteed bounds on π</h2>
<p><em>(<a href="http://sistemas.fciencias.unam.mx/~dsanders/">David P. Sanders</a>,  Department of Physics, Faculty of Sciences, National University of Mexico (UNAM)</em>)</p>
<h3 id="using-standard-floating-point-arithmetic">Using standard floating-point arithmetic</h3>
<p>We will calculate <em>guaranteed</em> (i.e., <em>validated</em>, or mathematically rigorous) bounds on $\pi$ using just floating-point arithmetic. This requires &ldquo;directed rounding&rdquo;, i.e. the ability to control in which direction floating-point operations are rounded.</p>
<p>This is based on the book <a href="http://press.princeton.edu/titles/9488.html"><em>Validated Numerics</em></a> (Princeton, 2011) by <a href="http://www2.math.uu.se/~warwick/CAPA/warwick/warwick.html">Warwick Tucker</a>.</p>
<p>Consider the infinite series</p>
<p>$$ S := \sum_{n=1}^\infty \frac{1}{n^2},$$</p>
<p>whose exact value is <a href="http://en.wikipedia.org/wiki/Basel_problem">known</a> to be $S = \frac{\pi^2}{6}$.
Thus, if finding guaranteed bounds on $S$ will give guaranteed bounds on $\pi$.</p>
<p>The idea is to split $S$ up into two parts, $S = S_N + T_N$, where
$ S_N := \sum_{n=1}^N \frac{1}{n^2}$ contains the first $N$ terms,
and $T_N := S - S_N = \sum_{n=N+1}^\infty \frac{1}{n^2}$ contains the rest (an infinite number of terms).</p>
<p>We will evalute $S_N$ numerically, and use the following analytical bound for $T_N$:</p>
<p>$$\frac{1}{N+1} \le T_N \le \frac{1}{N}$$.</p>
<p>This is obtained by approximating the sum in $T_N$ using integrals from below and above:</p>
<p>$$\int_{x=N+1}^\infty \frac{1}{x^2} dx \le T_N \le \int_{x=N}^\infty \frac{1}{x^2} dx.$$</p>
<p>$S_N$ may be calculated easily by summing either forwards or backwards:</p>
<pre><code class="language-julia">function forward_sum(N, T=Float64)
    total = zero(T)
    for i in 1:N
        total += one(T) / (i^2)
    end
    total
end

function reverse_sum(N, T=Float64)
    total = zero(T)
    for i in N:-1:1
        total += one(T) / (i^2)
    end
    total
end
</code></pre>
<pre><code>reverse_sum (generic function with 2 methods)
</code></pre>
<p>To find <em>rigorous</em> bounds for $S_N$, we use &ldquo;directed rounding&rdquo;, that is, we round downwards for the lower bound and  upwards for the upper bound:</p>
<pre><code class="language-julia">N = 10^6

lowerbound_S_N = 
    setrounding(Float64, RoundDown) do
        forward_sum(N)
    end

upperbound_S_N = 
    setrounding(Float64, RoundUp) do
        forward_sum(N)
    end

(lowerbound_S_N, upperbound_S_N)
</code></pre>
<pre><code>(1.6449330667377557,1.644933066959796)
</code></pre>
<p>We incorporate the respective bound on $T_N$ to obtain the bounds on $S$, and hence on $\pi$:</p>
<pre><code class="language-julia">N = 10^6

lower_π =
    setrounding(Float64, RoundDown) do
        lower_bound = forward_sum(N) + 1/(N+1)
        sqrt(6 * lower_bound)
    end

upper_π = 
    setrounding(Float64, RoundUp) do
        upper_bound = forward_sum(N) + 1/N
        sqrt(6 * upper_bound)
    end

(lower_π, upper_π, lowerbound_S_N)
</code></pre>
<pre><code>(3.1415926534833463,3.1415926536963346,1.6449330667377557)
</code></pre>
<pre><code class="language-julia">upper_π - lower_π
</code></pre>
<pre><code>2.1298829366855898e-10
</code></pre>
<p>We may check that the true value of $\pi$ is indeed contained in the interval:</p>
<pre><code class="language-julia">lower_π &lt; pi &lt; upper_π
</code></pre>
<pre><code>true
</code></pre>
<p>Summing in the opposite direction turns out to give a more accurate answer:</p>
<pre><code class="language-julia">N = 10^6

lower_π =
    setrounding(Float64, RoundDown) do
        lower_bound = reverse_sum(N) + 1/(N+1)
        sqrt(6 * lower_bound)
    end

upper_π = 
    setrounding(Float64, RoundUp) do
        upper_bound = reverse_sum(N) + 1/N
        sqrt(6 * upper_bound)
    end

(lower_π, upper_π)
</code></pre>
<pre><code>(3.1415926535893144,3.141592653590272)
</code></pre>
<pre><code class="language-julia">upper_π - lower_π
</code></pre>
<pre><code>9.57456336436735e-13
</code></pre>
<pre><code class="language-julia">lower_π &lt; pi &lt; upper_π
</code></pre>
<pre><code>true
</code></pre>
<p>In principle, we could attain arbitrarily good precision with higher-precision <code>BigFloat</code>s, but the result is hampered by the slow convergence of the series.</p>
<h2 id="summing-a-series-using-interval-arithmetic">Summing a series using interval arithmetic</h2>
<p>We repeat the calculation using <em>interval arithmetic</em>, provided by the <a href="https://github.com/dpsanders/ValidatedNumerics.jl">ValidatedNumerics.jl</a> package.</p>
<pre><code class="language-julia">using ValidatedNumerics
</code></pre>
<pre><code class="language-julia">setdisplay(:standard)  # abbreviated display of intervals
</code></pre>
<pre><code>6
</code></pre>
<pre><code class="language-julia">N = 10000
S = forward_sum(N, Interval)
S += 1/(N+1) .. 1/N  # interval bound on the remainder of the series
π_interval = √(6S)
</code></pre>
<pre><code>[3.14159, 3.1416]
</code></pre>
<p>Here we used an abbreviated display for the interval. Let's see the whole thing:</p>
<pre><code class="language-julia">setdisplay(:full)
π_interval
</code></pre>
<pre><code>Interval(3.1415926488148807, 3.141592658365341)
</code></pre>
<p>It's diameter (width) is</p>
<pre><code class="language-julia">diam(π_interval)
</code></pre>
<pre><code>9.550460422502738e-9
</code></pre>
<p>Thus, the result is correct to approximately 8 decimals.</p>
<p>In this calculation, we used the fact that arithmetic operations of intervals with numbers automatically promote the numbers to an interval:</p>
<pre><code class="language-julia">setdisplay(:full)  # full interval display
Interval(0) + 1/3^2
</code></pre>
<pre><code>Interval(0.1111111111111111, 0.11111111111111112)
</code></pre>
<p>This is an interval containing the true real number $1/9$ (written <code>1//9</code> in Julia):</p>
<pre><code class="language-julia">1//9 ∈ convert(Interval{Float64}, 1/3^2)
</code></pre>
<pre><code>true
</code></pre>
<p>Finally, we can check that the true value of $\pi$ is indeed inside our interval:</p>
<pre><code class="language-julia">pi ∈ π_interval
</code></pre>
<pre><code>true
</code></pre>
<h2 id="calculating-an-area">Calculating an area</h2>
<p>Although the calculation above is simple, the derivation of the series itself is not. In this section, we will use a more natural way to calculate $\pi$, namely that the area of a circle of radius $r$ is $A(r) = \pi r^2$. We will calculate the area of one quadrant of a circle of radius $r=2$, which is equal to $\pi$:</p>
<pre><code class="language-julia">using Plots; gr();
</code></pre>
<pre><code class="language-julia">f(x) = √(4 - x^2)
</code></pre>
<pre><code>f (generic function with 1 method)
</code></pre>
<pre><code class="language-julia">plot(f, 0, 2, aspect_ratio=:equal, fill=(0, :orange), alpha=0.2, label=&quot;&quot;)
</code></pre>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>The circle of radius $r=2$ is given by $x^2 + y^2 = 2^2 = 4$, so</p>
<p>$$\pi = \frac{1}{4} A(2) = \int_{x=0}^2 y(x) , dx = \int_{x=0}^2 \sqrt{4 - x^2}.$$</p>
<p>In calculus, we learn that we can approximate integrals using <strong>Riemann sums</strong>. Interval arithmetic allows us to make these Riemann sums <strong>rigorous</strong> in a very simple way, as follows.</p>
<p>We split up the $x$ axis into intervals, for example of equal width:</p>
<pre><code class="language-julia">function make_intervals(N=10)
    xs = linspace(0, 2, N+1)
    return [xs[i]..xs[i+1] for i in 1:length(xs)-1]
end

intervals = make_intervals()
</code></pre>
<pre><code>10-element Array{ValidatedNumerics.Interval{Float64},1}:
 Interval(0.0, 0.2)                               
 Interval(0.19999999999999998, 0.4)               
 Interval(0.39999999999999997, 0.6000000000000001)
 Interval(0.6, 0.8)                               
 Interval(0.7999999999999999, 1.0)                
 Interval(1.0, 1.2000000000000002)                
 Interval(1.2, 1.4000000000000001)                
 Interval(1.4, 1.6)                               
 Interval(1.5999999999999999, 1.8)                
 Interval(1.7999999999999998, 2.0)                
</code></pre>
<p>Given one of those intervals, we evaluate the function of interest:</p>
<pre><code class="language-julia">II = intervals[1]
</code></pre>
<pre><code>Interval(0.0, 0.2)
</code></pre>
<pre><code class="language-julia">f(II)
</code></pre>
<pre><code>Interval(1.9899748742132397, 2.0)
</code></pre>
<p>The result is an interval that is <strong>guaranteed to contain</strong> the true range of the function $f$ over that interval. So the lower and upper bounds of the intervals may be used as lower and upper bounds of the height of the box in a Riemann integral:</p>
<pre><code class="language-julia">intervals = make_intervals(30)

p = plot(aspect_ratio=:equal)
for X in intervals
    Y = f(X)
    
    plot!(IntervalBox(X, Interval(0, Y.lo)), c=:blue, label=&quot;&quot;, alpha=0.1)
    plot!(IntervalBox(X, Interval(Y.lo, Y.hi)), c=:red, label=&quot;&quot;, alpha=0.1)
end

plot!(f, 0, 2)

p
</code></pre>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Now we just sum up the areas:</p>
<pre><code class="language-julia">N = 20
intervals = make_intervals(N)

width = 2/N
width * sum(√(4 - X^2) for X in intervals)
</code></pre>
<pre><code>Interval(3.0284648797549782, 3.2284648797549846)
</code></pre>
<p>As we increase the number of sub-intervals, the approximation gets better and better:</p>
<pre><code class="language-julia">setdisplay(:standard, sigfigs=5)

println(&quot;N \t area interval \t \t diameter&quot;)
for N in 50:50:1000
    intervals = make_intervals(N)
    area = (2/N) * sum(√(4 - X^2) for X in intervals)
            
    println(&quot;$N \t $area \t $(diam(area))&quot;)
end
</code></pre>
<pre><code>N 	 area interval 	 	 diameter
50 	 [3.0982, 3.1783] 	 0.0800000000000165
100 	 [3.1204, 3.1605] 	 0.040000000000032454
150 	 [3.1276, 3.1543] 	 0.02666666666670814
200 	 [3.1311, 3.1512] 	 0.02000000000006308
250 	 [3.1332, 3.1493] 	 0.016000000000075065
300 	 [3.1346, 3.1481] 	 0.013333333333415354
350 	 [3.1356, 3.1472] 	 0.011428571428676815
400 	 [3.1364, 3.1465] 	 0.010000000000123688
450 	 [3.137, 3.146] 	 0.008888888889027502
500 	 [3.1374, 3.1455] 	 0.008000000000148333
550 	 [3.1378, 3.1452] 	 0.007272727272884527
600 	 [3.1381, 3.1449] 	 0.006666666666829357
650 	 [3.1384, 3.1446] 	 0.006153846154013376
700 	 [3.1386, 3.1444] 	 0.0057142857144931725
750 	 [3.1388, 3.1443] 	 0.005333333333562784
800 	 [3.139, 3.1441] 	 0.005000000000246363
850 	 [3.1391, 3.1439] 	 0.004705882353203794
900 	 [3.1393, 3.1438] 	 0.004444444444719142
950 	 [3.1394, 3.1437] 	 0.004210526316076102
1000 	 [3.1395, 3.1436] 	 0.004000000000294435
</code></pre>


  </div>

  

  </div>
  </div>
  </div>

  <br />

  


  <head>
  <meta name="description" content="We thank our contributors, donators, and Fastly for their support in keeping the Julia Language going. Donate here to help pay for Julia's needs."/>
</head>

<footer class="container-fluid footer-copy">
    <div class="container">
      <div class="row">
        <div class="col-md-10 py-2">
          <p>
            We thank <a style="color: #7a95dd" href="https://www.fastly.com">Fastly</a> for their generous infrastructure support. Donations help pay for community resources such as CI, Discourse, workshops, travel, JuliaCon, and other such needs.
          </p>
          <p>
            ©2019 JuliaLang.org contributors. The website content uses the <a style="color: #7a95dd" href="https://github.com/JuliaLang/www.julialang.org/blob/master/LICENSE.md">MIT license</a>.
          </p>
        </div>
        <div class="col-md-2 py-2">
          <a class="btn btn-success" href="https://numfocus.org/donate-to-julia">Donate</a>
        </div>
      </div>
    </div>
</footer>


  <script src="/v2/js/jquery.min.js"></script>
<script src="/v2/js/bootstrap.min.js"></script>
<script src="/v2/js/platform.js"></script>
<script src="/v2/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script async defer src="https://buttons.github.io/buttons.js"></script>

</body>

</html>
